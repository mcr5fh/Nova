// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
	"encoding/json"
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type EscalationAction string

const (
	EscalationActionFIX   EscalationAction = "FIX"
	EscalationActionHUMAN EscalationAction = "HUMAN"
	EscalationActionSKIP  EscalationAction = "SKIP"
)

// Values returns all allowed values for the EscalationAction type.
func (EscalationAction) Values() []EscalationAction {
	return []EscalationAction{
		EscalationActionFIX,
		EscalationActionHUMAN,
		EscalationActionSKIP,
	}
}

// IsValid checks whether the given EscalationAction value is valid.
func (e EscalationAction) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for EscalationAction.
func (e EscalationAction) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid EscalationAction: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for EscalationAction.
func (e *EscalationAction) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = EscalationAction(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid EscalationAction: %q", s)
	}
	return nil
}

func (e *EscalationAction) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "EscalationAction" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.EscalationAction, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = EscalationAction(value)
}

func (e EscalationAction) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("EscalationAction", string(e), false)
}

func (e EscalationAction) BamlTypeName() string {
	return "EscalationAction"
}

type TaskSize string

const (
	TaskSizeXS TaskSize = "XS"
	TaskSizeS  TaskSize = "S"
	TaskSizeM  TaskSize = "M"
	TaskSizeL  TaskSize = "L"
	TaskSizeXL TaskSize = "XL"
)

// Values returns all allowed values for the TaskSize type.
func (TaskSize) Values() []TaskSize {
	return []TaskSize{
		TaskSizeXS,
		TaskSizeS,
		TaskSizeM,
		TaskSizeL,
		TaskSizeXL,
	}
}

// IsValid checks whether the given TaskSize value is valid.
func (e TaskSize) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for TaskSize.
func (e TaskSize) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid TaskSize: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for TaskSize.
func (e *TaskSize) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = TaskSize(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid TaskSize: %q", s)
	}
	return nil
}

func (e *TaskSize) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "TaskSize" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.TaskSize, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = TaskSize(value)
}

func (e TaskSize) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("TaskSize", string(e), false)
}

func (e TaskSize) BamlTypeName() string {
	return "TaskSize"
}
