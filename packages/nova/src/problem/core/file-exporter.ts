import type { SessionState, DimensionId, ExportedProblemStatement, ExportFormat } from './types.js';
import { generateProblemStatement } from './output-formatter.js';
import { DIMENSIONS } from './dimensions.js';
import * as fs from 'fs/promises';
import * as path from 'path';

const EXPORT_VERSION = '1.0.0';

export type { ExportFormat };

/**
 * Creates the structured export data from a session state
 */
export function createExportData(state: SessionState): ExportedProblemStatement {
  const statement = generateProblemStatement(state);

  const dimensions = {} as Record<DimensionId, { coverage: string; evidence: string[] }>;
  for (const [id, dim] of Object.entries(state.dimensions)) {
    dimensions[id as DimensionId] = {
      coverage: dim.coverage,
      evidence: dim.evidence,
    };
  }

  return {
    problem: statement.problem,
    who: statement.who,
    frequencySeverity: statement.frequencySeverity,
    businessImpact: statement.businessImpact,
    validation: statement.validation,
    confidence: statement.confidence,
    gaps: statement.gaps,
    metadata: {
      sessionId: state.id,
      exportedAt: new Date().toISOString(),
      version: EXPORT_VERSION,
    },
    dimensions: dimensions as ExportedProblemStatement['dimensions'],
  };
}

/**
 * Exports session state to JSON format
 */
export function exportToJson(state: SessionState): string {
  const data = createExportData(state);
  return JSON.stringify(data, null, 2);
}

/**
 * Exports session state to Markdown format
 */
export function exportToMarkdown(state: SessionState): string {
  const data = createExportData(state);
  const lines: string[] = [];

  // Title
  lines.push('# Problem Statement');
  lines.push('');

  // Problem section
  lines.push('## Problem');
  lines.push('');
  lines.push(data.problem);
  lines.push('');

  // Who section
  lines.push('## Who');
  lines.push('');
  lines.push(data.who);
  lines.push('');

  // Frequency & Severity section
  lines.push('## Frequency & Severity');
  lines.push('');
  lines.push(data.frequencySeverity);
  lines.push('');

  // Business Impact section
  lines.push('## Business Impact');
  lines.push('');
  lines.push(data.businessImpact);
  lines.push('');

  // Validation section
  lines.push('## Validation');
  lines.push('');
  lines.push(data.validation);
  lines.push('');

  // Confidence
  lines.push('---');
  lines.push('');
  lines.push(`**Confidence:** ${data.confidence.toUpperCase()}`);
  lines.push('');

  // Gaps section (if any)
  if (data.gaps.length > 0) {
    lines.push('## Gaps');
    lines.push('');
    lines.push('The following areas need more detail:');
    lines.push('');
    for (const gap of data.gaps) {
      lines.push(`- **${DIMENSIONS[gap].name}**: ${DIMENSIONS[gap].description}`);
    }
    lines.push('');
  }

  // Dimensions summary
  lines.push('## Dimension Coverage');
  lines.push('');
  lines.push('| Dimension | Coverage | Evidence Count |');
  lines.push('|-----------|----------|----------------|');
  for (const [id, dim] of Object.entries(data.dimensions)) {
    const name = DIMENSIONS[id as DimensionId].name;
    lines.push(`| ${name} | ${dim.coverage} | ${dim.evidence.length} |`);
  }
  lines.push('');

  // Metadata footer
  lines.push('---');
  lines.push('');
  lines.push(`*Session ID: ${data.metadata.sessionId}*`);
  lines.push('');
  lines.push(`*Exported: ${data.metadata.exportedAt}*`);
  lines.push('');
  lines.push(`*Generated by Nova Problem Advisor v${data.metadata.version}*`);

  return lines.join('\n');
}

/**
 * Export session state to the specified format
 */
export function exportSession(state: SessionState, format: ExportFormat): string {
  switch (format) {
    case 'json':
      return exportToJson(state);
    case 'markdown':
      return exportToMarkdown(state);
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
}

/**
 * Result of detecting save intent from user input
 */
export interface SaveIntentResult {
  shouldSave: boolean;
  projectName: string | null;
}

/**
 * Detects if the user wants to save the project based on natural language input
 */
export function detectSaveIntent(input: string): SaveIntentResult {
  const trimmed = input.trim();
  const normalized = trimmed.toLowerCase();

  // Patterns that indicate user wants to save
  const savePatterns = [
    /^save$/,                           // just "save"
    /^save\s+(this|it)$/,              // "save this", "save it"
    /^(please\s+)?save(\s+this)?$/,    // "please save", "please save this"
    /^let'?s\s+save(\s+this)?$/,       // "let's save this"
  ];

  // Pattern for "save as <name>" or "save this as <name>" - case-insensitive but preserve case in capture
  const saveAsPattern = /^(?:let'?s\s+)?(?:please\s+)?save(?:\s+(?:this|it))?\s+as\s+(.+)$/i;

  // Check for "save as <name>" first - use the original trimmed input to preserve case
  const saveAsMatch = trimmed.match(saveAsPattern);
  if (saveAsMatch) {
    return { shouldSave: true, projectName: saveAsMatch[1].trim() };
  }

  // Check for simple save patterns
  for (const pattern of savePatterns) {
    if (pattern.test(normalized)) {
      return { shouldSave: true, projectName: null };
    }
  }

  return { shouldSave: false, projectName: null };
}

/**
 * Converts a project name to a safe kebab-case filename
 */
function toKebabCase(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, ' ')  // Replace special characters with spaces
    .replace(/\s+/g, '-')            // Replace spaces with hyphens
    .replace(/-+/g, '-')             // Collapse multiple hyphens
    .replace(/^-|-$/g, '');          // Trim leading/trailing hyphens
}

/**
 * Exports session state to project Markdown format with Solution placeholder
 */
export function exportToProjectMarkdown(state: SessionState, projectName: string): string {
  const data = createExportData(state);
  const lines: string[] = [];

  // Title uses project name
  lines.push(`# ${projectName}`);
  lines.push('');

  // Problem section
  lines.push('## Problem');
  lines.push('');
  lines.push(data.problem);
  lines.push('');

  // Who section
  lines.push('## Who');
  lines.push('');
  lines.push(data.who);
  lines.push('');

  // Frequency & Severity section
  lines.push('## Frequency & Severity');
  lines.push('');
  lines.push(data.frequencySeverity);
  lines.push('');

  // Business Impact section
  lines.push('## Business Impact');
  lines.push('');
  lines.push(data.businessImpact);
  lines.push('');

  // Validation section
  lines.push('## Validation');
  lines.push('');
  lines.push(data.validation);
  lines.push('');

  // Solution placeholder section
  lines.push('## Solution');
  lines.push('');
  lines.push('*To be defined*');
  lines.push('');

  // Confidence
  lines.push('---');
  lines.push('');
  lines.push(`**Confidence:** ${data.confidence.toUpperCase()}`);
  lines.push('');

  // Gaps section (if any)
  if (data.gaps.length > 0) {
    lines.push('## Gaps');
    lines.push('');
    lines.push('The following areas need more detail:');
    lines.push('');
    for (const gap of data.gaps) {
      lines.push(`- **${DIMENSIONS[gap].name}**: ${DIMENSIONS[gap].description}`);
    }
    lines.push('');
  }

  // Metadata footer
  lines.push('---');
  lines.push('');
  lines.push(`*Session ID: ${data.metadata.sessionId}*`);
  lines.push('');
  lines.push(`*Generated by Nova Problem Advisor v${data.metadata.version}*`);

  return lines.join('\n');
}

/**
 * Writes the project file to specs/projects/<name>.md
 * @returns The path to the written file
 */
export async function writeProjectFile(
  state: SessionState,
  projectName: string,
  basePath: string
): Promise<string> {
  const projectsDir = path.join(basePath, 'specs', 'projects');
  const filename = `${toKebabCase(projectName)}.md`;
  const filePath = path.join(projectsDir, filename);

  // Ensure the directory exists
  await fs.mkdir(projectsDir, { recursive: true });

  // Generate and write the content
  const content = exportToProjectMarkdown(state, projectName);
  await fs.writeFile(filePath, content, 'utf-8');

  return filePath;
}
