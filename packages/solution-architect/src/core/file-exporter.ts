import { SessionState, DimensionId, ExportFormat, ExportedSolutionSpec, LoadedProblem } from './types.js';
import { generateSolutionSpec } from './output-formatter.js';
import { DIMENSIONS } from './dimensions.js';
import * as fs from 'fs/promises';
import * as path from 'path';

const EXPORT_VERSION = '1.0.0';

export { ExportFormat };

/**
 * Creates the structured export data from a session state
 */
export function createExportData(state: SessionState, flowDiagram?: string): ExportedSolutionSpec {
  const spec = generateSolutionSpec(state);

  const dimensions = {} as Record<DimensionId, { coverage: string; evidence: string[] }>;
  for (const [id, dim] of Object.entries(state.dimensions)) {
    dimensions[id as DimensionId] = {
      coverage: dim.coverage,
      evidence: dim.evidence,
    };
  }

  return {
    solutionSummary: spec.solutionSummary,
    userValue: spec.userValue,
    scope: spec.scope,
    successCriteria: spec.successCriteria,
    userFlow: flowDiagram || '',
    confidence: spec.confidence,
    gaps: spec.gaps,
    problemContext: state.loadedProblem || undefined,
    metadata: {
      sessionId: state.id,
      exportedAt: new Date().toISOString(),
      version: EXPORT_VERSION,
    },
    dimensions: dimensions as ExportedSolutionSpec['dimensions'],
  };
}

/**
 * Exports session state to JSON format
 */
export function exportToJson(state: SessionState, flowDiagram?: string): string {
  const data = createExportData(state, flowDiagram);
  return JSON.stringify(data, null, 2);
}

/**
 * Exports session state to Markdown format
 */
export function exportToMarkdown(state: SessionState, flowDiagram?: string): string {
  const data = createExportData(state, flowDiagram);
  const lines: string[] = [];

  // Title
  lines.push('# Solution Specification');
  lines.push('');

  // Problem Context (if loaded)
  if (data.problemContext) {
    lines.push('## Problem Context');
    lines.push('');
    lines.push(`**Problem:** ${data.problemContext.problem}`);
    lines.push('');
    lines.push(`**Who:** ${data.problemContext.who}`);
    lines.push('');
    if (data.problemContext.businessImpact) {
      lines.push(`**Business Impact:** ${data.problemContext.businessImpact}`);
      lines.push('');
    }
    lines.push('---');
    lines.push('');
  }

  // Solution Summary
  lines.push('## Solution');
  lines.push('');
  lines.push(data.solutionSummary);
  lines.push('');

  // User Value
  lines.push('## User Value');
  lines.push('');
  lines.push(data.userValue);
  lines.push('');

  // Scope
  lines.push('## Scope');
  lines.push('');
  lines.push('### In Scope');
  lines.push('');
  for (const item of data.scope.included) {
    lines.push(`- ${item}`);
  }
  lines.push('');

  lines.push('### Out of Scope');
  lines.push('');
  for (const item of data.scope.excluded) {
    lines.push(`- ${item}`);
  }
  lines.push('');

  if (data.scope.futureConsiderations.length > 0) {
    lines.push('### Future Considerations');
    lines.push('');
    for (const item of data.scope.futureConsiderations) {
      lines.push(`- ${item}`);
    }
    lines.push('');
  }

  // Success Criteria
  lines.push('## Success Criteria');
  lines.push('');
  for (const criterion of data.successCriteria) {
    lines.push(`- ${criterion}`);
  }
  lines.push('');

  // User Flow
  if (data.userFlow) {
    lines.push('## User Flow');
    lines.push('');
    lines.push('```');
    lines.push(data.userFlow);
    lines.push('```');
    lines.push('');
  }

  // Confidence
  lines.push('---');
  lines.push('');
  lines.push(`**Confidence:** ${data.confidence.toUpperCase()}`);
  lines.push('');

  // Gaps section (if any)
  if (data.gaps.length > 0) {
    lines.push('## Gaps');
    lines.push('');
    lines.push('The following areas need more detail:');
    lines.push('');
    for (const gap of data.gaps) {
      lines.push(`- **${DIMENSIONS[gap].name}**: ${DIMENSIONS[gap].description}`);
    }
    lines.push('');
  }

  // Dimensions summary
  lines.push('## Dimension Coverage');
  lines.push('');
  lines.push('| Dimension | Coverage | Evidence Count |');
  lines.push('|-----------|----------|----------------|');
  for (const [id, dim] of Object.entries(data.dimensions)) {
    const name = DIMENSIONS[id as DimensionId].name;
    lines.push(`| ${name} | ${dim.coverage} | ${dim.evidence.length} |`);
  }
  lines.push('');

  // Metadata footer
  lines.push('---');
  lines.push('');
  lines.push(`*Session ID: ${data.metadata.sessionId}*`);
  lines.push('');
  lines.push(`*Exported: ${data.metadata.exportedAt}*`);
  lines.push('');
  lines.push(`*Generated by Solution Architect v${data.metadata.version}*`);

  return lines.join('\n');
}

/**
 * Export session state to the specified format
 */
export function exportSession(state: SessionState, format: ExportFormat, flowDiagram?: string): string {
  switch (format) {
    case 'json':
      return exportToJson(state, flowDiagram);
    case 'markdown':
      return exportToMarkdown(state, flowDiagram);
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
}

/**
 * Result of detecting save intent from user input
 */
export interface SaveIntentResult {
  shouldSave: boolean;
  solutionName: string | null;
}

/**
 * Detects if the user wants to save the solution based on natural language input
 */
export function detectSaveIntent(input: string): SaveIntentResult {
  const trimmed = input.trim();
  const normalized = trimmed.toLowerCase();

  // Patterns that indicate user wants to save
  const savePatterns = [
    /^save$/,
    /^save\s+(this|it)$/,
    /^(please\s+)?save(\s+this)?$/,
    /^let'?s\s+save(\s+this)?$/,
  ];

  // Pattern for "save as <name>" - case-insensitive but preserve case in capture
  const saveAsPattern = /^(?:let'?s\s+)?(?:please\s+)?save(?:\s+(?:this|it))?\s+as\s+(.+)$/i;

  // Check for "save as <name>" first
  const saveAsMatch = trimmed.match(saveAsPattern);
  if (saveAsMatch) {
    return { shouldSave: true, solutionName: saveAsMatch[1].trim() };
  }

  // Check for simple save patterns
  for (const pattern of savePatterns) {
    if (pattern.test(normalized)) {
      return { shouldSave: true, solutionName: null };
    }
  }

  return { shouldSave: false, solutionName: null };
}

/**
 * Converts a solution name to a safe kebab-case filename
 */
function toKebabCase(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, ' ')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

/**
 * Result of saving a solution
 */
export interface SaveSolutionResult {
  saved: boolean;
  filePath?: string;
  solutionName?: string;
}

/**
 * Exports session state to solution Markdown format
 */
export function exportToSolutionMarkdown(state: SessionState, solutionName: string, flowDiagram?: string): string {
  const data = createExportData(state, flowDiagram);
  const lines: string[] = [];

  // Title with solution name
  lines.push(`# ${solutionName}`);
  lines.push('');
  lines.push('## Solution Specification');
  lines.push('');

  // Problem Context
  if (data.problemContext) {
    lines.push('### Problem Context');
    lines.push('');
    lines.push(`> ${data.problemContext.problem}`);
    lines.push(`>`);
    lines.push(`> **Who:** ${data.problemContext.who}`);
    lines.push('');
  }

  // Solution
  lines.push('### Solution');
  lines.push('');
  lines.push(data.solutionSummary);
  lines.push('');

  // User Value
  lines.push('### User Value');
  lines.push('');
  lines.push(data.userValue);
  lines.push('');

  // Scope
  lines.push('### Scope');
  lines.push('');
  lines.push('**In Scope:**');
  for (const item of data.scope.included) {
    lines.push(`- ${item}`);
  }
  lines.push('');
  lines.push('**Out of Scope:**');
  for (const item of data.scope.excluded) {
    lines.push(`- ${item}`);
  }
  lines.push('');

  if (data.scope.futureConsiderations.length > 0) {
    lines.push('**Future Considerations:**');
    for (const item of data.scope.futureConsiderations) {
      lines.push(`- ${item}`);
    }
    lines.push('');
  }

  // Success Criteria
  lines.push('### Success Criteria');
  lines.push('');
  for (const criterion of data.successCriteria) {
    lines.push(`- ${criterion}`);
  }
  lines.push('');

  // User Flow
  if (data.userFlow) {
    lines.push('### User Flow');
    lines.push('');
    lines.push('```');
    lines.push(data.userFlow);
    lines.push('```');
    lines.push('');
  }

  // Implementation section (placeholder)
  lines.push('---');
  lines.push('');
  lines.push('## Implementation');
  lines.push('');
  lines.push('*To be planned...*');
  lines.push('');

  // Metadata
  lines.push('---');
  lines.push('');
  lines.push(`**Confidence:** ${data.confidence}`);
  lines.push('');
  lines.push(`*Generated by Solution Architect v${data.metadata.version}*`);

  return lines.join('\n');
}

/**
 * Writes the solution file to specs/solutions/<name>.md
 * @returns The path to the written file
 */
export async function writeSolutionFile(
  state: SessionState,
  solutionName: string,
  basePath: string,
  flowDiagram?: string
): Promise<string> {
  const solutionsDir = path.join(basePath, 'specs', 'solutions');
  const filename = `${toKebabCase(solutionName)}.md`;
  const filePath = path.join(solutionsDir, filename);

  // Ensure the directory exists
  await fs.mkdir(solutionsDir, { recursive: true });

  // Generate and write the content
  const content = exportToSolutionMarkdown(state, solutionName, flowDiagram);
  await fs.writeFile(filePath, content, 'utf-8');

  return filePath;
}

/**
 * Load a problem statement from a problem-advisor export file
 */
export async function loadProblemStatement(filePath: string): Promise<LoadedProblem> {
  const content = await fs.readFile(filePath, 'utf-8');
  const ext = path.extname(filePath).toLowerCase();

  if (ext === '.json') {
    return parseProblemJson(content, filePath);
  } else if (ext === '.md' || ext === '.markdown') {
    return parseProblemMarkdown(content, filePath);
  } else {
    throw new Error(`Unsupported file format: ${ext}. Use .json or .md`);
  }
}

/**
 * Parse problem statement from JSON format
 */
function parseProblemJson(content: string, sourceFile: string): LoadedProblem {
  const data = JSON.parse(content);

  return {
    problem: data.problem || 'Unknown',
    who: data.who || 'Unknown',
    frequencySeverity: data.frequencySeverity,
    businessImpact: data.businessImpact,
    validation: data.validation,
    confidence: data.confidence,
    sourceFile,
  };
}

/**
 * Parse problem statement from Markdown format
 */
function parseProblemMarkdown(content: string, sourceFile: string): LoadedProblem {
  const result: LoadedProblem = {
    problem: 'Unknown',
    who: 'Unknown',
    sourceFile,
  };

  // Extract sections from markdown
  const lines = content.split('\n');
  let currentSection = '';

  for (const line of lines) {
    const trimmed = line.trim();

    // Detect section headers
    if (trimmed.startsWith('## ')) {
      currentSection = trimmed.slice(3).toLowerCase();
      continue;
    }

    // Extract content based on current section
    if (trimmed && !trimmed.startsWith('#') && !trimmed.startsWith('|') && !trimmed.startsWith('*')) {
      if (currentSection === 'problem' && result.problem === 'Unknown') {
        result.problem = trimmed;
      } else if (currentSection === 'who' && result.who === 'Unknown') {
        result.who = trimmed;
      } else if (currentSection === 'frequency & severity' || currentSection === 'frequency/severity') {
        result.frequencySeverity = trimmed;
      } else if (currentSection === 'business impact') {
        result.businessImpact = trimmed;
      } else if (currentSection === 'validation') {
        result.validation = trimmed;
      }
    }

    // Check for confidence in bold format
    if (trimmed.startsWith('**Confidence:**')) {
      const confidence = trimmed.replace('**Confidence:**', '').trim().toLowerCase();
      if (confidence === 'low' || confidence === 'medium' || confidence === 'high') {
        result.confidence = confidence;
      }
    }
  }

  return result;
}
