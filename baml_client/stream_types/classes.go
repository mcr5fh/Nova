// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package stream_types

import (
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"

	"github.com/mattruiters/nova/baml_client/types"
)

type EscalationDecision struct {
	Action         *types.EscalationAction `json:"action"`
	Reason         *string                 `json:"reason"`
	Fixer_prompt   *string                 `json:"fixer_prompt"`
	Human_question *string                 `json:"human_question"`
}

func (c *EscalationDecision) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "EscalationDecision" {
		panic(fmt.Sprintf("expected EscalationDecision, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "action":
			c.Action = baml.Decode(valueHolder).Interface().(*types.EscalationAction)

		case "reason":
			c.Reason = baml.Decode(valueHolder).Interface().(*string)

		case "fixer_prompt":
			c.Fixer_prompt = baml.Decode(valueHolder).Interface().(*string)

		case "human_question":
			c.Human_question = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class EscalationDecision", key))

		}
	}

}

func (c EscalationDecision) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["action"] = c.Action

	fields["reason"] = c.Reason

	fields["fixer_prompt"] = c.Fixer_prompt

	fields["human_question"] = c.Human_question

	return baml.EncodeClass("EscalationDecision", fields, nil)
}

func (c EscalationDecision) BamlTypeName() string {
	return "EscalationDecision"
}

type PlannerDecision struct {
	Size         *types.TaskSize     `json:"size"`
	Should_split *bool               `json:"should_split"`
	Subtasks     []SubtaskDefinition `json:"subtasks"`
	Reasoning    *string             `json:"reasoning"`
}

func (c *PlannerDecision) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "PlannerDecision" {
		panic(fmt.Sprintf("expected PlannerDecision, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "size":
			c.Size = baml.Decode(valueHolder).Interface().(*types.TaskSize)

		case "should_split":
			c.Should_split = baml.Decode(valueHolder).Interface().(*bool)

		case "subtasks":
			c.Subtasks = baml.Decode(valueHolder).Interface().([]SubtaskDefinition)

		case "reasoning":
			c.Reasoning = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class PlannerDecision", key))

		}
	}

}

func (c PlannerDecision) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["size"] = c.Size

	fields["should_split"] = c.Should_split

	fields["subtasks"] = c.Subtasks

	fields["reasoning"] = c.Reasoning

	return baml.EncodeClass("PlannerDecision", fields, nil)
}

func (c PlannerDecision) BamlTypeName() string {
	return "PlannerDecision"
}

type SubtaskDefinition struct {
	Id          *string                            `json:"id"`
	Title       *string                            `json:"title"`
	Description *string                            `json:"description"`
	Type        *types.Union3KbugOrKfeatureOrKtask `json:"type"`
	Priority    *int64                             `json:"priority"`
	Depends_on  []string                           `json:"depends_on"`
}

func (c *SubtaskDefinition) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "SubtaskDefinition" {
		panic(fmt.Sprintf("expected SubtaskDefinition, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "id":
			c.Id = baml.Decode(valueHolder).Interface().(*string)

		case "title":
			c.Title = baml.Decode(valueHolder).Interface().(*string)

		case "description":
			c.Description = baml.Decode(valueHolder).Interface().(*string)

		case "type":
			c.Type = baml.Decode(valueHolder).Interface().(*types.Union3KbugOrKfeatureOrKtask)

		case "priority":
			c.Priority = baml.Decode(valueHolder).Interface().(*int64)

		case "depends_on":
			c.Depends_on = baml.Decode(valueHolder).Interface().([]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class SubtaskDefinition", key))

		}
	}

}

func (c SubtaskDefinition) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["id"] = c.Id

	fields["title"] = c.Title

	fields["description"] = c.Description

	fields["type"] = c.Type

	fields["priority"] = c.Priority

	fields["depends_on"] = c.Depends_on

	return baml.EncodeClass("SubtaskDefinition", fields, nil)
}

func (c SubtaskDefinition) BamlTypeName() string {
	return "SubtaskDefinition"
}

type TelemetryEntry struct {
	Task_id       *string  `json:"task_id"`
	Attempt_num   *int64   `json:"attempt_num"`
	Model         *string  `json:"model"`
	Tokens_used   *int64   `json:"tokens_used"`
	Duration_ms   *int64   `json:"duration_ms"`
	Cost_usd      *float64 `json:"cost_usd"`
	Success       *bool    `json:"success"`
	Error_message *string  `json:"error_message"`
}

func (c *TelemetryEntry) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "TelemetryEntry" {
		panic(fmt.Sprintf("expected TelemetryEntry, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "task_id":
			c.Task_id = baml.Decode(valueHolder).Interface().(*string)

		case "attempt_num":
			c.Attempt_num = baml.Decode(valueHolder).Interface().(*int64)

		case "model":
			c.Model = baml.Decode(valueHolder).Interface().(*string)

		case "tokens_used":
			c.Tokens_used = baml.Decode(valueHolder).Interface().(*int64)

		case "duration_ms":
			c.Duration_ms = baml.Decode(valueHolder).Interface().(*int64)

		case "cost_usd":
			c.Cost_usd = baml.Decode(valueHolder).Interface().(*float64)

		case "success":
			c.Success = baml.Decode(valueHolder).Interface().(*bool)

		case "error_message":
			c.Error_message = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class TelemetryEntry", key))

		}
	}

}

func (c TelemetryEntry) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["task_id"] = c.Task_id

	fields["attempt_num"] = c.Attempt_num

	fields["model"] = c.Model

	fields["tokens_used"] = c.Tokens_used

	fields["duration_ms"] = c.Duration_ms

	fields["cost_usd"] = c.Cost_usd

	fields["success"] = c.Success

	fields["error_message"] = c.Error_message

	return baml.EncodeClass("TelemetryEntry", fields, nil)
}

func (c TelemetryEntry) BamlTypeName() string {
	return "TelemetryEntry"
}

type ValidationResult struct {
	Passed   *bool    `json:"passed"`
	Message  *string  `json:"message"`
	Failures []string `json:"failures"`
}

func (c *ValidationResult) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ValidationResult" {
		panic(fmt.Sprintf("expected ValidationResult, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "passed":
			c.Passed = baml.Decode(valueHolder).Interface().(*bool)

		case "message":
			c.Message = baml.Decode(valueHolder).Interface().(*string)

		case "failures":
			c.Failures = baml.Decode(valueHolder).Interface().([]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ValidationResult", key))

		}
	}

}

func (c ValidationResult) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["passed"] = c.Passed

	fields["message"] = c.Message

	fields["failures"] = c.Failures

	return baml.EncodeClass("ValidationResult", fields, nil)
}

func (c ValidationResult) BamlTypeName() string {
	return "ValidationResult"
}

type WorkerResult struct {
	Success       *bool    `json:"success"`
	Summary       *string  `json:"summary"`
	Output_files  []string `json:"output_files"`
	Confidence    *float64 `json:"confidence"`
	Questions     []string `json:"questions"`
	Error_message *string  `json:"error_message"`
}

func (c *WorkerResult) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "WorkerResult" {
		panic(fmt.Sprintf("expected WorkerResult, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "success":
			c.Success = baml.Decode(valueHolder).Interface().(*bool)

		case "summary":
			c.Summary = baml.Decode(valueHolder).Interface().(*string)

		case "output_files":
			c.Output_files = baml.Decode(valueHolder).Interface().([]string)

		case "confidence":
			c.Confidence = baml.Decode(valueHolder).Interface().(*float64)

		case "questions":
			c.Questions = baml.Decode(valueHolder).Interface().([]string)

		case "error_message":
			c.Error_message = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class WorkerResult", key))

		}
	}

}

func (c WorkerResult) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["success"] = c.Success

	fields["summary"] = c.Summary

	fields["output_files"] = c.Output_files

	fields["confidence"] = c.Confidence

	fields["questions"] = c.Questions

	fields["error_message"] = c.Error_message

	return baml.EncodeClass("WorkerResult", fields, nil)
}

func (c WorkerResult) BamlTypeName() string {
	return "WorkerResult"
}
