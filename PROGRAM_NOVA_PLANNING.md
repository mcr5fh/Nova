# Program Nova - Planning Document

## What This Is

A program that reads a CASCADE.md file (a hierarchical task breakdown for a software project), executes worker agents to complete the tasks, and provides a real-time web dashboard for observability and control.

The cascade file defines a tree: Level 0 (project) → Level 1 (major systems) → Level 2 (component groups) → Level 3 (leaf tasks). Each leaf task is a small, atomic unit of work that a single AI coding agent can implement, test, and commit.

---

## Two Responsibilities

### 1. Execution Engine
Reads the cascade, resolves dependency order, spawns Claude Code worker agents to implement leaf tasks, captures their output and token usage, and updates shared state as tasks progress.

### 2. Observability Dashboard
A web UI that reads shared state and renders a drill-down view of the cascade hierarchy with live status, duration, token usage, cost, and milestone notifications.

These two systems communicate through a single shared state file. They are decoupled — the dashboard is read-only and can run independently.

---

## Shared State File

This is the central primitive. A JSON file on disk that the execution engine writes to and the dashboard reads from.

### Schema

```
{
  "project": {
    "name": "string",
    "cascade_file": "path to CASCADE.md",
    "started_at": "ISO timestamp or null",
    "completed_at": "ISO timestamp or null"
  },
  "tasks": {
    "<task_id>": {
      "status": "pending | in_progress | completed | failed",
      "worker_id": "string or null",
      "pid": "integer or null (OS process ID of the worker)",
      "started_at": "ISO timestamp or null",
      "completed_at": "ISO timestamp or null",
      "duration_seconds": "integer",
      "current_step": "string or null (last reported activity)",
      "token_usage": {
        "input_tokens": "integer",
        "output_tokens": "integer",
        "cache_read_tokens": "integer",
        "cache_creation_tokens": "integer"
      },
      "error": "string or null (failure reason if failed)",
      "commit_sha": "string or null",
      "files_changed": ["array of file paths"]
    }
  }
}
```

### Rules
- File location: project root, named `cascade_state.json`
- Only the execution engine writes to this file
- The dashboard only reads it
- For in-progress tasks, live duration is computed by the dashboard as `now - started_at`
- Token usage is cumulative (updated as the worker progresses)

---

## Cascade File Parser

The program must parse CASCADE.md to extract the task hierarchy. The parser needs to produce:

### Task Graph
For each leaf task:
- **id**: The task identifier (e.g., F1, P3, R2)
- **name**: Human-readable task name
- **description**: What the task involves (the "What Changes" column)
- **depends_on**: List of task IDs that must complete before this task can start
- **group**: Which L2 group it belongs to (e.g., "Foundation", "Provider Layer")
- **branch**: Which L1 branch it belongs to (e.g., "Application", "Infrastructure")

### Hierarchy Map
For rollup calculations:
- L1 branches and which L2 groups belong to each
- L2 groups and which leaf tasks belong to each
- This mapping is what enables the drill-down UI and status rollup

### Dependency Resolution
The parser must build a directed acyclic graph (DAG) from the "Depends On" column. A task is "ready" when:
- Status is `pending`
- All tasks in its `depends_on` list have status `completed`

---

## Execution Engine

### Worker Lifecycle

1. **Claim**: Engine picks a ready task (pending, all deps satisfied), marks it `in_progress` in state file, records `started_at` and `worker_id`
2. **Execute**: Engine spawns a Claude Code agent as a subprocess. The agent receives the task description as its prompt, along with context about the project and any relevant files. Agent stdout/stderr is captured to a log file at `logs/<task_id>.log`
3. **Monitor**: Engine periodically reads the subprocess to check if it's still alive. If the agent writes progress markers to stdout, the engine can parse them and update `current_step` in the state file
4. **Complete**: When the subprocess exits, the engine reads the exit code. Exit 0 = completed, anything else = failed. Engine updates the state file with final status, `completed_at`, `duration_seconds`, token usage, commit SHA, and files changed
5. **Advance**: Engine rechecks the DAG for newly ready tasks and repeats

### Token Usage Tracking

Claude Code reports token usage. The execution engine needs to capture this information from the worker agent's output or API response metadata. The key metrics are:
- **input_tokens**: Tokens sent to the model
- **output_tokens**: Tokens generated by the model
- **cache_read_tokens**: Tokens served from prompt cache (cheaper)
- **cache_creation_tokens**: Tokens written to prompt cache

These are used for cost estimation. The dashboard computes cost using known model pricing.

### Log Capture

Every worker's stdout and stderr must be written to `logs/<task_id>.log`. This is essential for:
- Debugging failed tasks
- Understanding what the agent did
- The dashboard's task detail view

### Concurrency

The engine should support configurable max concurrent workers (e.g., 3). It should not start more workers than this limit, even if more tasks are ready. Tasks should be started in dependency order — when multiple tasks are ready, prefer lower-numbered tasks or tasks on the critical path.

### Failure Handling

When a task fails:
- Mark it `failed` in the state file with an error message
- Do NOT mark downstream tasks as failed — leave them `pending` but effectively blocked
- The dashboard will show these as blocked (gray) because their dependency is not `completed`
- A failed task can be manually retried (re-mark as `pending`, engine will pick it up again)

---

## Web Dashboard

### Navigation Model

The dashboard uses progressive drill-down. The user starts at the top level and clicks into successive layers of detail.

**View 1: L0 (Project Overview)**
Shows the 3 L1 branches as cards/rows. Each shows:
- Name (Application, Infrastructure, DevOps & Testing)
- Status color (green/yellow/red/gray)
- Progress fraction (e.g., 18/27 tasks)
- Aggregate duration
- Aggregate token usage
- Aggregate cost estimate
- Click to drill into L1

Also shows:
- Overall progress bar (e.g., 22/47 tasks, 46%)
- Total project duration
- Total project cost
- Milestones panel (see below)

**View 2: L1 Detail (e.g., Application)**
Shows the L2 groups within the selected L1 branch as cards/rows. Each shows:
- Name (Foundation, Provider Layer, Routing Engine, etc.)
- Status color
- Progress fraction
- Aggregate duration, tokens, cost for that group
- Click to drill into L2

Back button returns to L0.

**View 3: L2 Detail (e.g., Foundation)**
Shows the individual leaf tasks within the selected L2 group as a table/list. Each shows:
- Task ID and name
- Status icon (checkmark, spinner, X, circle)
- Duration (live-updating if in-progress)
- Token count
- Cost
- Click to drill into task detail

Back button returns to L1.

**View 4: Task Detail**
Shows everything about a single leaf task:
- Status, duration, timestamps
- Full token usage breakdown (input, output, cache read, cache creation)
- Cost estimate
- Worker ID
- Commit SHA (linkable if using git)
- Files changed
- Agent logs (scrollable, auto-updating if task is in-progress)

Back button returns to L2.

### Status Color Logic

- **Green**: All tasks in that group are `completed`
- **Yellow**: At least one task is `in_progress`, none are `failed`
- **Red**: At least one task is `failed`
- **Gray**: No tasks started yet (all `pending`)

Rollup: A parent inherits the "worst" status of its children. Red > Yellow > Gray > Green.

### Live Updates

Dashboard polls the backend API every 2 seconds. On each poll:
- Refresh all task statuses
- Recompute rollups
- Recompute live duration for in-progress tasks (now - started_at)
- Check for new milestones

No websockets needed. Polling is simple and sufficient for this use case.

### Milestones

Milestones are defined alongside the cascade (either in CASCADE.md or a companion file). A milestone is:
- A human-readable message (e.g., "API server is running — test at localhost:8000")
- A set of task IDs that must all be `completed` to trigger it
- An optional action hint (URL, command to run)

When all trigger tasks complete, the milestone appears in the milestones panel on the L0 view. This tells the user they can go interact with something even while other tasks are still running.

Example milestones:
- When F1+F2+F3+F4 complete: "Foundation is ready — core types and interfaces are defined"
- When A1+A3+K3+K4 complete: "API is testable — try curl http://localhost:8000/v1/models"
- When P1+P2+P3+P5 complete: "Bedrock integration works — can route requests to AWS"
- When all Application tasks complete: "Application layer complete — ready for deployment"

### Cost Calculation

The dashboard computes cost from token usage. Pricing is configurable but defaults to current Claude model pricing. Cost = (input_tokens * input_price) + (output_tokens * output_price) + (cache_read * cache_read_price) + (cache_creation * cache_creation_price). Display as USD with 2 decimal places.

---

## API Endpoints

The dashboard needs a small backend API. This can be the same FastAPI process or a separate lightweight server.

### Endpoints

```
GET  /api/status          → Full state with computed rollups, live durations, milestones
GET  /api/tasks/{id}      → Single task detail
GET  /api/tasks/{id}/logs → Raw log file content for a task
GET  /                    → Serve the dashboard HTML/JS/CSS
```

The `/api/status` response should include:
- Raw task states from `cascade_state.json`
- Computed rollups for each L2 group and L1 branch
- Live duration for in-progress tasks
- Triggered milestones
- Project-level aggregates (total tasks, complete count, total duration, total cost)

---

## File Structure

```
program_nova/
├── cascade_state.json         # Shared state file (written by engine, read by dashboard)
├── logs/                      # Worker log files
│   ├── F1.log
│   ├── F2.log
│   └── ...
├── engine/                    # Execution engine
│   ├── orchestrator.py        # Main loop: parse cascade, resolve deps, spawn workers
│   ├── worker.py              # Worker management: spawn, monitor, capture output
│   ├── parser.py              # CASCADE.md parser → task graph + hierarchy
│   ├── state.py               # Read/write cascade_state.json with file locking
│   └── update_task.py         # CLI tool for workers to report status
├── dashboard/                 # Web dashboard
│   ├── server.py              # FastAPI backend: serves API + static files
│   ├── static/                # Frontend assets
│   │   ├── index.html         # Single-page app with drill-down views
│   │   ├── styles.css         # Styling
│   │   └── app.js             # Frontend logic: polling, rendering, navigation
│   └── rollup.py              # Compute rollup status/duration/tokens/cost
└── milestones.yaml            # Milestone definitions (trigger tasks + messages)
```

---

## Key Design Decisions

1. **JSON file as state store, not a database.** Simple, inspectable, no dependencies. File locking prevents corruption from concurrent writes.

2. **Dashboard is read-only.** It never modifies state. This means you can restart the dashboard at any time without affecting execution.

3. **Workers are subprocesses.** Each worker is a separate OS process. This means they can be killed with standard signals (SIGTERM/SIGKILL). The PID is stored in state for this purpose.

4. **Token usage is first-class.** Not an afterthought. Every task tracks input, output, cache read, and cache creation tokens. This data rolls up through the hierarchy so you can see cost at every level.

5. **Duration is tracked at every level.** For in-progress tasks, the dashboard computes it live. For completed tasks, it's stored as a final value. Rollups sum durations for aggregate views.

6. **Milestones are declarative.** They're defined as "when tasks X, Y, Z are all done, show this message." The dashboard evaluates them on every poll. No special event system needed.

7. **The cascade file is the source of truth for structure.** The state file only tracks execution status. If you change CASCADE.md (add/remove/rename tasks), the system should handle it gracefully.

8. **Polling over websockets.** 2-second polling is simple, reliable, and sufficient for a dashboard that shows task status. No need for real-time push infrastructure.

---

## What Success Looks Like

1. Start the execution engine pointing at a CASCADE.md file
2. Workers begin implementing leaf tasks in dependency order
3. Open the dashboard in a browser
4. See 3 L1 cards on the overview page with live progress
5. Click into "Application" → see 6 L2 groups with their status
6. Click into "Foundation" → see F1-F4 with live durations and token counts
7. Click into F1 → see agent logs streaming in real-time
8. See a milestone notification: "API is testable" when the right tasks complete
9. See total project cost accumulating in the header
10. When a task fails, see it go red, click in, read the logs, understand what went wrong
